%! TEX root = ../../mersenne.tex

\subsection{Related Work}

Simple Power Analysis on Fast Modular Reduction with
Generalized Mersenne Prime for Elliptic Curve Cryptosystems

https://pdfs.semanticscholar.org/3f84/39b357a8331f1cc6f8de68a19223ff027f2c.pdf

\begin{algorithm}
   \caption{Fast reduction modulo $p_{192} = 2^{192} - 2^{64} - 1$}
   \begin{algorithmic}
      \State \textbf{input} $c \gets (c_5, c_4, c_3, c_2, c_1, c_0)$, where each $c_i$ is a 64-bit word, and $0 \le c < p^2_{192}$.
      \State $s_0 = (c_2, c_1, c_0)$
      \State $s_0 = (0, c_3, c_3)$
      \State $s_0 = (c_4, c_4, 0)$
      \State $s_0 = (c_5, c_5, c_5)$
      \State \textbf{return} $s_0 + s_1 + s_2 + s_3 \mod p_{192}$.
   \end{algorithmic}
\end{algorithm}
That's weird.

In~\cite{granger2013generalised} the authors defined a different family of Generalised Mersenne numbers and showed various fast multiplication and reduction schemes.

Other methods:
 - Classical one using divisions
 - Montgomery's method
 - ! Barrett reduction

Modified Crandall Algorithm:
https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4016496

Does modulo in parallel with division (which we have shown is unnecessary), but taking only the division parts the algorithm is
\begin{algorithm}
   \begin{algorithmic}[1]
      \Procedure{Divide}{x, n, c}
         \State $q_0 \gets \lfloor x/2^n\rfloor$
         \State $r_0 \gets x \bmod 2^n$
         \State $q \gets q_0$
         \State $r \gets r_0$
         \State $i \gets 0$
         \While{$q_i>0$}
            \State $t \gets q_i c$
            \State $q_{i+1} \gets \lfloor t / 2^n\rfloor$
            \State $r_{i+1} \gets t \bmod 2^n$
            \State $q\gets q+q_{i+1}$
            \State $r\gets r+r_{i+1}$
            \State $i\gets i+1$
         \EndWhile
         \State $t \gets 2^n-c$
         \While{$r\ge t$}
            \State $r\gets r-t$
            \State $q\gets q+1$
         \EndWhile
         \State\textbf{return} $q$
      \EndProcedure
   \end{algorithmic}
\end{algorithm}

No proof of correctness is given.
The while loop condition is different.
No guarantees on running time.
The addition is different from ours.
Doesn't add 1. Doesn't add $x$.
Has that extra weird loop for fixing things in the end.
So it actually has to do the $r$ computation?


Words:
 GM, PM reduction: Module af Generalized or Pseudo-Mersennes.

The most important case is ``Modular Multiplication'', in which we are given two $w$-word numbers, $x,y$ and want to compute $xy\mod p$ which is again a $w$-word number.

Montgomery method:
\begin{align}
   (aR\mod N)(bR\mod N) \mod N = (abR)R \mod N
\end{align}
We then need to remove the factor of $R$ by multiplying with its inverse $\mod N$.



Unfortunately there are only 45 of them known.
The most useful one perhaps being.

Heuristically there are $O(\log x)$ Mersenne primes up to $x$.


Trivia:
Euler proved that an even number $n$ is perfect if and only if it is on the form $n=2^{q-1}M_q$, where $M_q=2^q-1$ is prime.
(Usually we know a number is perfect if its divisors sum to the number itself, e.g. $6=1+2+3$ or $28=1+2+4+7+14$.)

Four of the recommended primes in NIST's document "Recommended Elliptic Curves for Federal Government Use" are Solinas primes:


%[[Curve448]] uses the Solinas prime <math>2^{448} - 2^{224} - 1</math>

The classical Mersenne mod algorithm.
Write $n = a2^p + b$, then
\begin{align}
   n \mod M_p = \begin{cases}
      a + b & \text{if } a+b<M_p\\
      a + b + 1 - 2^p & \text{otherwise}.
   \end{cases}
\end{align}

Thus reduction modulo a Mersenne prime requires an
integer addition, as opposed to an integer division for
modular reduction in the general case. There are two
drawbacks to this method of modular reduction:
\begin{itemize}
   \item Finding the integers a and b is easiest when p is a multiple of word size of the machine, since then there is
no actual shifting of bits needed to align a and b for
the modular addition. But word sizes are in practice
powers of two, whereas p must be an odd prime.
   \item The Mersenne primes are so rare, with none between
      $M_{127}$ and $M_{521}$ hat usually there will be none of the desired magnitude.
\end{itemize}
For these reasons~\cite{van2014encyclopedia}, cryptographers tend not to use Mersenne primes, preferring similar moduli such as pseudo-Mersenne primes and generalized Mersenne primes.

\paragraph{Pseudo-Mersenne primes}
On the form $p = 2^n-k$.
If $x < p^2$, write $x = a 2^{2n} + b 2^m + c$,
where $a\in\{0,1\}$.
(Note, if $k > 0$, we always have $a=0$.)
Then $n \mod p = ak^2+bk+c$.
Repeating this a few times gives the calculation.


\paragraph{Generalised Mersenne primes}
Solinas algorithm
